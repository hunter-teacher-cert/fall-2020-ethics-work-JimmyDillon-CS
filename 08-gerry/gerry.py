# -*- coding: utf-8 -*-
"""gerry.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uuDMgIwTwDNRD4wkuSXYG_uYXyQp5lgT
"""

# Colab link: https://colab.research.google.com/drive/1uuDMgIwTwDNRD4wkuSXYG_uYXyQp5lgT?usp=sharing

# import statements
import random as rn
import math
import copy
import requests
from google.colab import files
#uploaded = files.upload()
url = 'https://raw.githubusercontent.com/JimmyDillon-CS/public/main/all_districts.txt'
uploaded = requests.get(url).text
#print(uploaded)

# This creates a 2-d array that represents the districts

#result = str(uploaded.values())
result = str(uploaded)
result = result.split("\n")
#result[0]=result[0][-112:]
#print(len(result[0]))
a_d = []
for x in result:
  y = x[-113:] # removes the space at the front of the string
  tmp = y.split(", ") # splits by ", "
  a_d.append(copy.deepcopy(tmp))
  tmp.clear()

# sets the size of the state and number of parties

state_width = 3
state_length = 6
parties = 2

# A state contains a name and a 6x3 grid of cells.
class State:
  
  def __init__ (self, name, cells):
    self.name = name
    self.cells = cells
  
  def __str__(self):
    return "State Name: % s Cells: % s" % (self.name, self.cells)

# Creates a state by adding random 1's and 0's into (rows) arrays
# and placing those rows into a new array.
def create_state (name):
  tmp_cells = []
  row = []

  for x in range(0, state_length):
    row.clear()
    for y in range(0, state_width):
      row.append(rn.randint(0,parties-1))
    #print(row)
    tmp_cells.append(copy.deepcopy(row))

  new_state = State (name, copy.deepcopy(tmp_cells))
  tmp_cells.clear()
  return new_state

#maryland = create_state("maryland")
#print(maryland)

# Cleanly displays a state as a 6 x 3 grid
def display_state (my_state):
  print ("State Name: " + my_state.name)
  print ("----------------------------")
  print (" +---+---+---+")
  for x in range(0, state_length):
    for y in range (0, state_width):
      print(" | ", end="")
      print (my_state.cells[x][y], end="")
    print (" |")
    print (" +---+---+---+")

#display_state(maryland)

# Given a state and a district configuration.
# Returns the number of districts won by the 1-party

def district_score (my_state, district):
  zero_score = 0
  one_score = 0
  
  for x in range(0, state_length):
    count = 0
    coords = district[x]

    #print(coords)
    #print(coords[0])
    #print(coords[1])

    x_val = int(coords[1])
    y_val = int(coords[3])
    
    if my_state.cells[y_val][x_val] == 1:
        count+=1
    
    x_val = int(coords[7])
    y_val = int(coords[9])
    
    if my_state.cells[y_val][x_val] == 1:
        count+=1
    
    x_val = int(coords[13])
    y_val = int(coords[15])
    
    if my_state.cells[y_val][x_val] == 1:
        count+=1
    
    if count>1:
      one_score+=1
    else:
      zero_score+=1

  return one_score

#print(a_d[0])
#district_score(maryland, a_d[0])

# Given a state, calculates the state's percentage of 1's. 
# Determines the number of districts that 1 should win.

def state_score(my_state):
  score = 0
  for x in range(0, state_length):
    for y in range (0, state_width):
      score+=my_state.cells[x][y]
  #print(score)
  return score

#state_score(maryland)

# Determines if a cell is in a district.

def find_cell (coords, district):
  for x in range(0, state_length):
    if district[x].find(coords) != -1:
      return x
  return

# Given a state and district
# Prints a color-coded state by district

def display_district(my_state, district):
  print("")
  print (" +---+---+---+")
  for x in range(0, state_length):
    for y in range (0, state_width):
      color_offset = find_cell (str(y) + "," + str(x), district)
      color = "\u001b[" + str(color_offset+31)+"m "
      print(" |", end="")
      print (color+str(my_state.cells[x][y])+"\u001b[0m", end="")
    print(" |")
    print(" +---+---+---+")
  return

#display_district(maryland, dist)

# Given a state and a projected number of winning districts
# Returns the district that works best 

def find_dist(my_state, score):
  for x in a_d:
    dist_score = district_score(my_state, x)
    if dist_score == score:
      return x
  
  return

# Finds the best district by walking through each district configuration
# and return the one that most closely approcimates the one to zero ratio.

def best_district (my_state):
  score = state_score(my_state)
  print ("STATE BREAKDOWN:")
  print ("----------------")
  print ("0: " + str(18-score) + " (" + str(round((18-score)/18, 2)) + "%)")
  print ("1: " + str(score) + " (" + str(round(score/18, 2)) + "%)")
  one_dists = int(round(score/3))
  zero_dists = 6 - one_dists
  print("")
  print ("Your state should contain: ")
  print ("---------------")
  print ("0-districts: " + str(zero_dists))
  print ("1-districts: " + str(one_dists))

  best_fit_dist = find_dist(my_state, one_dists)

  display_district(my_state, best_fit_dist)

  return

# Runs the show

def main():
  empire = create_state ("empire")
  display_state(empire)
  best_district(empire)

main()